package ycble.runchinaup.ota.absimpl.xc;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothGatt;import android.bluetooth.BluetoothGattCharacteristic;import android.bluetooth.BluetoothGattDescriptor;import android.bluetooth.BluetoothGattService;import android.content.Context;import android.os.Build;import android.os.Handler;import android.support.annotation.NonNull;import android.util.Log;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.Arrays;import java.util.Deque;import java.util.LinkedList;import java.util.UUID;import ycble.runchinaup.ota.absimpl.xc.no.nordicsemi.android.BleManager;import ycble.runchinaup.ota.absimpl.xc.no.nordicsemi.android.Request;import ycble.runchinaup.ota.absimpl.xc.no.nordicsemi.android.utils.ParserUtils;import static ycble.runchinaup.ota.absimpl.xc.Crc32.CRC32_INIT_VAL;public class MeshOTAManager extends BleManager<OTAManagerCallbacks> {    public final static String ERROR_CONNECTION_STATE_CHANGE = "Error on connection state change";    public final static String ERROR_DISCOVERY_SERVICE = "Error on discovering services";    public final static String ERROR_AUTH_ERROR_WHILE_BONDED = "Phone has lost bonding information";    public final static String ERROR_READ_CHARACTERISTIC = "Error on reading characteristic";    public final static String ERROR_WRITE_CHARACTERISTIC = "Error on writing characteristic";    public final static String ERROR_READ_DESCRIPTOR = "Error on reading descriptor";    public final static String ERROR_WRITE_DESCRIPTOR = "Error on writing descriptor";    public final static String ERROR_MTU_REQUEST = "Error on mtu request";    public final static String ERROR_CONNECTION_PRIORITY_REQUEST = "Error on connection priority request";    public final static String ERROR_READ_RSSI = "Error on RSSI read";    public final static String ERROR_READ_PHY = "Error on PHY read";    public final static String ERROR_PHY_UPDATE = "Error on PHY update";    public final static String ERROR_RELIABLE_WRITE = "Error on Execute Reliable Write";    /**     * The maximum packet size is 20 bytes.     */    private static final int MAX_PACKET_SIZE = 20;    public static final int MTU_SIZE_MIN = 23;    private static final int MTU_SIZE_MAX = 40;    /**     * Mesh provisioning data in characteristic UUID     */    //用于标识ota是否成功    private boolean isSuccess;    public boolean isSuccess() {        return isSuccess;    }    /**     * Mesh OTA service UUID     */    public final static UUID MESH_OTA_UUID = UUID.fromString("00002600-0000-1000-8000-00805F9B34FB");    private final static UUID MESH_OTA_CHAR_CTRL_UUID = UUID.fromString("00007000-0000-1000-8000-00805F9B34FB");    private final static UUID MESH_OTA_CHAR_DATA_UUID = UUID.fromString("00007001-0000-1000-8000-00805F9B34FB");    public static final UUID CCCD = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");    private final String TAG = MeshOTAManager.class.getSimpleName();    private BluetoothGattCharacteristic ctrlChar;    private BluetoothGattCharacteristic dataChar;    private BluetoothGatt mBluetoothGatt;    public final static int BXOTA_CTRL_PKT_START_REQ = 0;    public final static int BXOTA_CTRL_PKT_START_RSP = 1;    public final static int BXOTA_CTRL_PKT_NEW_BLOCK_CMD = 2;    public final static int BXOTA_CTRL_PKT_IMAGE_TRANSFER_FINISH_CMD = 3;    public final static int BXOTA_CTRL_PKT_SIGN_DATA_SEND = 4;    public final static int BXOTA_CTRL_PKT_SIGN_DATA_RSP = 5;    private byte[] OTAData;    private boolean[] currentAck;    private int blockNum;    private int maxSegmentNumInBlock;    private int lastBlockSegmentNum;    private short currentBlock;    private short currentSegment;    private short maxSegmentDataSize = 19;    private final short blockHeaderSize = 1;    private final static int MAX_SIGNATURE_SEGMENT_COUNT = 4 - 1;//index from 0 so max segindex=size-1    public void setNeedCheckSign(boolean mNeedCheckSign) {        this.mNeedCheckSign = mNeedCheckSign;    }    private boolean mNeedCheckSign;    private boolean mNeedCrc32 = false;    private static final int MAX_SIGN_SEG_SIZE = 16;    public void setNeedCrc32(boolean mNeedCrc32) {        this.mNeedCrc32 = mNeedCrc32;    }    public void setSignData(byte[] signData) {        this.signData = signData;    }    private byte[] signData;    public MeshOTAManager(Context context, byte[] otaData) {        super(context);        this.OTAData = otaData;        isSuccess = false;    }    private Handler handler = new Handler();    BleManagerGattCallback bleManagerGattCallback = new BleManagerGattCallback() {        @Override        protected Deque<Request> initGatt(@NonNull BluetoothGatt gatt) {            isOtaAReady = false;            final LinkedList<Request> requests = new LinkedList<>();            mBluetoothGatt = gatt;            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {                mBluetoothGatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);            }            ctrlChar.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);            mBluetoothGatt.setCharacteristicNotification(ctrlChar, true);            dataChar.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);            mBluetoothGatt.setCharacteristicNotification(dataChar, true);            BluetoothGattDescriptor ctrlDesc = ctrlChar.getDescriptor(CCCD);            ctrlDesc.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);            mBluetoothGatt.writeDescriptor(ctrlDesc);            return null;        }        @Override        protected boolean isRequiredServiceSupported(@NonNull BluetoothGatt gatt) {            for (BluetoothGattService service : gatt.getServices()) {                if (service.getUuid().toString().equals(MESH_OTA_UUID.toString())) {                    log(Log.DEBUG, "Service:" + service.getUuid().toString());                    for (BluetoothGattCharacteristic characteristic : service.getCharacteristics()) {                        log(Log.DEBUG, "characteristic:" + characteristic.getUuid().toString());                    }                } else {                }            }            boolean writeRequest;            BluetoothGattService meshService = gatt.getService(MESH_OTA_UUID);            if (meshService != null) {                log(Log.DEBUG, "found OTA services  ");                ctrlChar = meshService.getCharacteristic(MESH_OTA_CHAR_CTRL_UUID);                dataChar = meshService.getCharacteristic(MESH_OTA_CHAR_DATA_UUID);                writeRequest = false;                if (dataChar != null) {                    final int rxProperties = dataChar.getProperties();                    writeRequest = (rxProperties & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) > 0;                }                return (ctrlChar != null && dataChar != null && writeRequest);            }            log(Log.DEBUG, "OTA service not support");            return false;        }        @Override        protected void onDeviceDisconnected() {        }        @Override        protected void onCharacteristicIndicated(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {            super.onCharacteristicIndicated(gatt, characteristic);            log(Log.DEBUG, "onCharacteristicIndicated: " + characteristic.getUuid().toString());            if (characteristic.getUuid().compareTo(MESH_OTA_CHAR_CTRL_UUID) == 0) {                ctrlPktIndicationRX(characteristic.getValue());            }        }        @Override        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            if (status == 0) {                super.onCharacteristicWrite(gatt, characteristic, status);            } else {                if (!isOtaAReady) {                    startOtaRequest();                }            }        }        @Override        protected void onCharacteristicWrite(@NonNull BluetoothGatt gatt, @NonNull BluetoothGattCharacteristic characteristic) {            super.onCharacteristicWrite(gatt, characteristic);            if (characteristic.getUuid().compareTo(MESH_OTA_CHAR_CTRL_UUID) == 0) {                byte[] txBytes = characteristic.getValue();                ctrlPktSent(txBytes);            } else if (characteristic.getUuid().compareTo(MESH_OTA_CHAR_DATA_UUID) == 0) {                OTATransferContinue(false);            }        }        @Override        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {//            super.onDescriptorWrite(gatt, descriptor, status);            log(Log.INFO, "onDescriptorWrite:" + descriptor.getUuid().toString());            if (descriptor.getUuid().compareTo(CCCD) == 0) {                startOtaRequest();            }        }        @Override        protected void onCharacteristicRead(@NonNull BluetoothGatt gatt, @NonNull BluetoothGattCharacteristic characteristic) {            super.onCharacteristicRead(gatt, characteristic);            final byte[] data = characteristic.getValue();            log(Log.DEBUG, "dataReceived: " + ParserUtils.parse(data));            if (characteristic.getUuid().compareTo(MESH_OTA_CHAR_DATA_UUID) == 0) {                onAckRead(characteristic.getValue());            }        }        @Override        public void onCharacteristicNotified(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {            super.onCharacteristicNotified(gatt, characteristic);        }        @Override        protected void onMtuChanged(@NonNull int mtu) {            super.onMtuChanged(mtu);            maxSegmentDataSize = (short) (mtu - 3 - blockHeaderSize);            log(Log.DEBUG, "onMtuChanged: " + maxSegmentDataSize);        }    };    @Override    public void log(int priority, @NonNull String message) {        super.log(priority, message);        if (priority == Log.DEBUG)            mCallbacks.print(message);        Log.d(TAG, message);    }    @NonNull    @Override    protected BleManagerGattCallback getGattCallback() {        return bleManagerGattCallback;    }    private void segmentTX() {        int length = getSegmentLength(currentBlock, currentSegment);        byte[] data = new byte[blockHeaderSize + length];        data[0] = (byte) currentSegment;        data[1] = (byte) (currentSegment >> 8);        System.arraycopy(OTAData, (currentBlock * maxSegmentNumInBlock + currentSegment) * maxSegmentDataSize                , data, blockHeaderSize, length);        dataChar.setValue(data);        writeCharacteristic(dataChar, data);    }    private int getSegmentLength(int blockID, int segmentID) {        if (blockID == blockNum - 1 && segmentID == lastBlockSegmentNum - 1) {            return OTAData.length - maxSegmentDataSize *                    ((blockNum - 1) * maxSegmentNumInBlock + (lastBlockSegmentNum - 1));        } else {            return maxSegmentDataSize;        }    }    public void readAck() {        mBluetoothGatt.readCharacteristic(dataChar);    }    public void writeDescriptor() {    }    void OTATransferContinue(boolean newBlock) {        int segmentNum = getSegmentNumOfCurrentBlock();        if (newBlock) {            currentSegment = 0;            log(Log.DEBUG, "newBlock start..");        } else {            ++currentSegment;        }        while (currentSegment < segmentNum && currentAck[currentSegment]) {            ++currentSegment;        }        if (currentSegment == segmentNum) {            log(Log.DEBUG, "Seg 1 ~ seg " + segmentNum + " write complete then read ack");            readAck();        } else {            segmentTX();        }    }    private void ctrlPktTX(int type, byte[] param) {        byte[] ctrl;        if (param != null) {            ctrl = new byte[param.length + 1];            System.arraycopy(param, 0, ctrl, 1, param.length);        } else {            ctrl = new byte[1];        }        ctrl[0] = (byte) type;//        ctrlChar.setValue(ctrl);        if (type == BXOTA_CTRL_PKT_START_REQ) {            log(Log.DEBUG, "send start reuest:" + Arrays.toString(ctrl));        } else if (type == BXOTA_CTRL_PKT_NEW_BLOCK_CMD) {            log(Log.DEBUG, "send new block cmd:" + Arrays.toString(ctrl));        } else if (type == BXOTA_CTRL_PKT_IMAGE_TRANSFER_FINISH_CMD) {            log(Log.DEBUG, "send transfer comolete cmd:" + Arrays.toString(ctrl));        } else {        }        writeCharacteristic(ctrlChar, ctrl);    }    private void newBlockCmd() {        mCallbacks.print("currentBlock:" + currentBlock);        byte[] blockIDArray = new byte[]{(byte) currentBlock, (byte) (currentBlock >> 8)};        ctrlPktTX(BXOTA_CTRL_PKT_NEW_BLOCK_CMD, blockIDArray);    }    private void imageTXFinishCmd() {        ctrlPktTX(BXOTA_CTRL_PKT_IMAGE_TRANSFER_FINISH_CMD, null);    }    private boolean isOtaAReady;    void ctrlPktSent(byte[] txData) {        switch (txData[0]) {            case BXOTA_CTRL_PKT_START_REQ:                isOtaAReady = true;                log(Log.DEBUG, "ota ready: ");                break;            case BXOTA_CTRL_PKT_NEW_BLOCK_CMD:                Arrays.fill(currentAck, false);                OTATransferContinue(true);                break;            case BXOTA_CTRL_PKT_IMAGE_TRANSFER_FINISH_CMD:                log(Log.DEBUG, "ota  complete....: ");                isSuccess = true;                handler.postDelayed(new Runnable() {                    @Override                    public void run() {                        disconnect();                    }                }, 100);                break;            case BXOTA_CTRL_PKT_SIGN_DATA_SEND:                mCallbacks.print(String.format("sign data:%d of 4 send complete", +txData[1]));                if (txData[1] < MAX_SIGNATURE_SEGMENT_COUNT) {                    transSignDataCmd(txData[1] + 1);                } else {                    startOTATransfer();                }                break;            default:                break;        }    }    void transSignDataCmd(int index) {        int type = BXOTA_CTRL_PKT_SIGN_DATA_SEND;        int nextIndex = index;        byte[] data = new byte[17];        data[0] = (byte) index;        System.arraycopy(signData, nextIndex * MAX_SIGN_SEG_SIZE, data, 1, MAX_SIGN_SEG_SIZE);        log(Log.DEBUG, ParserUtils.parse(data));        ctrlPktTX(type, data);    }    private void startOtaRequest() {        mCallbacks.onOTARequestStart();        int lenth = mNeedCrc32 ? 10 : 2;        ByteBuffer buffer = ByteBuffer.allocate(lenth).order(ByteOrder.LITTLE_ENDIAN);        byte[] maxBlockDataSizeArray = new byte[]{(byte) maxSegmentDataSize, (byte) (maxSegmentDataSize >> 8)};        buffer.put(maxBlockDataSizeArray);        if (mNeedCrc32) {            buffer.putInt(crc32());            buffer.putInt(OTAData.length);        }        log(Log.DEBUG, "startOtaRequest: " + maxSegmentDataSize);        ctrlPktTX(BXOTA_CTRL_PKT_START_REQ, buffer.array());    }    private int crc32() {        Crc32 crc32 = new Crc32();        long crc = crc32.crc32_calc(CRC32_INIT_VAL, OTAData, OTAData.length);        return (int) crc;    }    void ctrlPktIndicationRX(byte[] rxData) {        int status = rxData[1];        switch (rxData[0]) {            case BXOTA_CTRL_PKT_START_RSP:                log(Log.DEBUG, "received OTA start Resp");                maxSegmentNumInBlock = rxData[2] * 8;                log(Log.DEBUG, "total segments size(): " + maxSegmentNumInBlock);                currentAck = new boolean[maxSegmentNumInBlock];                if (status == 0) {                    if (mNeedCheckSign) {                        transSignDataCmd(0);                    } else {                        startOTATransfer();                    }                }                break;            case BXOTA_CTRL_PKT_SIGN_DATA_RSP:                String mOtaStatus = status == 1 ? "OTA Status:" + "success" : "failed";                log(Log.DEBUG, mOtaStatus);                break;            default:                break;        }    }    private void startOTATransfer() {        mCallbacks.onOTAStart();        new Thread(new Runnable() {            @Override            public void run() {                blockNum = (int) Math.ceil((double) OTAData.length / (maxSegmentDataSize * maxSegmentNumInBlock));                log(Log.DEBUG, "block num :" + blockNum);                int lastBlockDataLength = OTAData.length % (maxSegmentDataSize * maxSegmentNumInBlock);                lastBlockSegmentNum = (int) Math.ceil((double) lastBlockDataLength / maxSegmentDataSize);                currentBlock = 0;                newBlockCmd();            }        }).start();    }    private int getSegmentNumOfCurrentBlock() {        if (currentBlock == blockNum - 1) {            return lastBlockSegmentNum;        } else {            return maxSegmentNumInBlock;        }    }    void onAckRead(byte[] rxBytes) {        boolean allAcked = true;        int segmentNum = getSegmentNumOfCurrentBlock();        for (int i = 0; i < segmentNum; ++i) {            //check  data send            if ((rxBytes[i / 8] & (1 << i % 8)) != 0) {                currentAck[i] = true;            } else {                // transfor filed                allAcked = false;                currentAck[i] = false;            }        }        if (allAcked) {            float progress = (float) (currentBlock + 1) / blockNum;            //OTA 进度            if (mCallbacks != null) {                mCallbacks.onProgress(progress);            }            if (++currentBlock == blockNum) {                log(Log.DEBUG, "OTA Complete");                imageTXFinishCmd();            } else {                log(Log.DEBUG, " next block:" + currentBlock);                newBlockCmd();            }        } else {            //tranfor failed >>continue transfor            OTATransferContinue(true);        }    }    @Override    public void connect(@NonNull BluetoothDevice device) {        isSuccess = false;        super.connect(device);    }}